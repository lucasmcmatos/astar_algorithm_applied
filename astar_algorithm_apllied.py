# -*- coding: utf-8 -*-
"""astar_algorithm_apllied.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ouZFb9jiWCUA4vukLJczkVZSbHvJDgFp
"""

# IMPLEMENTACAO DO GRAFO (MAPA) USANDO O NETWORKX

# Importa NetworkX (Biblioteca para criacao de grafos)
import networkx as nx

# Craindo grafo (mapa)
grafo = nx.Graph()

# Adicionando os nos (cidades) no grafo (mapa)
grafo.add_node("Sao Luis")
grafo.add_node("Santa Ines")
grafo.add_node("Bacabal")
grafo.add_node("Bacabeira")
grafo.add_node("Barreirinhas")
grafo.add_node("Caxias")
grafo.add_node("Grajau")
grafo.add_node("Imperatriz")
grafo.add_node("Balsas")
grafo.add_node("Alcantara")
grafo.add_node("Viana")
grafo.add_node("Acailandia")
grafo.add_node("Pinheiro")

# Adicionar arestas (estradas) ao grafo (mapa) com seus pesos (distancias)
grafo.add_edge("Sao Luis", "Bacabeira", weight=61.8)
grafo.add_edge("Bacabeira", "Barreirinhas", weight=198.8)
grafo.add_edge("Bacabeira", "Santa Ines", weight=189.4)
grafo.add_edge("Santa Ines", "Bacabal", weight=90.6)
grafo.add_edge("Bacabal", "Caxias", weight=194.2)
grafo.add_edge("Caxias", "Grajau", weight=389)
grafo.add_edge("Grajau", "Imperatriz", weight=189)
grafo.add_edge("Grajau", "Balsas", weight=243)
grafo.add_edge("Imperatriz", "Balsas", weight=390)
grafo.add_edge("Santa Ines", "Acailandia", weight=317)
grafo.add_edge("Acailandia", "Imperatriz", weight=67.9)
grafo.add_edge("Bacabeira", "Viana", weight=155)
grafo.add_edge("Viana", "Alcantara", weight=213)
grafo.add_edge("Santa Ines", "Pinheiro", weight=179)
grafo.add_edge("Pinheiro", "Alcantara", weight=112)
grafo.add_edge("Balsas", "Caxias", weight=535)
grafo.add_edge("Viana", "Pinheiro", weight=127)
grafo.add_edge("Barreirinhas", "Bacabal", weight=390)
grafo.add_edge("Barreirinhas", "Santa Ines", weight=385)
grafo.add_edge("Acailandia", "Caxias", weight=809)

# VIZUALIZACAO DO GRAFO (MAPA)

# Importacao Matplotlib (Biblioteca para visualizacao do grafo)
import matplotlib.pyplot as plt

# Defincao da posicao dos nos (cidades)
pos = nx.spring_layout(grafo)

# Desenhando o grafo (mapa)
nx.draw_networkx(grafo, with_labels=True,node_size=500,node_color="lightblue", width=2)

plt.show()

# IMPLEMENTACAO DO ALGORITMO A* (na mao)

# Importacao da bilioteca Heapq (Trabalhar com filas de prioredade baseada em heaps)
import heapq

# Definicao de um funcao extra para vizualizacao do grafo com o caminho destacado
def plotar_grafo_com_caminho(grafo, caminho):
    pos = nx.spring_layout(grafo)  # Posições dos nós para plotagem
    nx.draw(grafo, pos, with_labels=True, node_color='lightblue', node_size=700)  # Desenhar o grafo

    # Extrair as arestas do caminho
    arestas_caminho = [(caminho[i], caminho[i + 1]) for i in range(len(caminho) - 1)]

    # Desenhar as arestas do caminho em vermelho
    nx.draw_networkx_edges(grafo, pos, edgelist=arestas_caminho, edge_color='red', width=2, label='Distância mais curta pela vias')

    # Adicionar a linha reta do nó de origem ao nó de destino
    origem = caminho[0]
    destino = caminho[-1]
    coord_origem = pos[origem]
    coord_destino = pos[destino]
    plt.plot([coord_origem[0], coord_destino[0]], [coord_origem[1], coord_destino[1]], color="red", linestyle='--', linewidth=2, label='Distância em linha reta')

    plt.legend()
    plt.show()

# Definicao da funcao que implementa a heuristica manhattan
def heuristica_manhattan(origem, destino, grafo):
  coord_origem = nx.spring_layout(grafo)[origem]
  coord_destino = nx.spring_layout(grafo)[destino]
  return abs(coord_origem[0] - coord_destino[0]) + abs(coord_origem[1] - coord_destino[1])

# Definicao da funcao que implementa o algoritmo A*
def astar(origem, destino, grafo, heuristica):
  fronteira = [] # Fila de prioridade com tuplas (f, g, h, no_atual)
  visitados = set()  # Conjunto de nós já visitados
  caminho = {}  # Dicionário para reconstruir o caminho

  # Inserindo o no incial na fronteira
  heapq.heappush(fronteira, (heuristica(origem, destino, grafo), 0, heuristica(origem, destino, grafo), origem))

  while fronteira:
    # Removendo o no com menor f da fronteira
    _, g, _, no_atual = heapq.heappop(fronteira)

    # Verificando se chegou ao seu destino / Criando a string com a resposta
    if no_atual == destino:
      caminho_reverso = [no_atual]
      while no_atual in caminho:
          no_atual = caminho[no_atual]
          caminho_reverso.append(no_atual)
      caminho_reverso.reverse()
      distancia = sum(grafo[u][v]['weight'] for u, v in zip(caminho_reverso[:-1], caminho_reverso[1:]))
      caminho_mais_curto = " --> ".join(caminho_reverso)

      # Apresentacao do resultado
      print("Caminho encontrado com sucesso!\n\n - Caminho mais curto: ", caminho_mais_curto, "\n - Distancia mais curta pelas vias (no real): ", distancia, "km\n - Tamanho da linha reta no grafo: ", heuristica(vizinho, destino, grafo), "\n - Vizualize o caminho destacado no grafo abaixo: \n")
      plotar_grafo_com_caminho(grafo, caminho_reverso)
      return "Operacao realizada com sucesso!"

    # Marcando o no atual como ja visitado
    visitados.add(no_atual)

    # Explorando o no vizinho
    for vizinho, peso in grafo[no_atual].items():
            if vizinho in visitados:
                continue

            g_vizinho = g + peso['weight']
            h_vizinho = heuristica(vizinho, destino, grafo)
            f_vizinho = g_vizinho + h_vizinho

            # Se o vizinho da esta na fronteira, atualizar se necessario
            if vizinho in [x[3] for x in fronteira]:
                index = next(index for index, (_, _, _, node) in enumerate(fronteira) if node == vizinho)
                if f_vizinho < fronteira[index][0]:
                    fronteira[index] = (f_vizinho, g_vizinho, h_vizinho, vizinho)
                    heapq.heapify(fronteira)

            # Caso contrario, adicionar na fronteira
            else:
                heapq.heappush(fronteira, (f_vizinho, g_vizinho, h_vizinho, vizinho))
                caminho[vizinho] = no_atual

  # Resposta caso nao encontre nenhum caminho
  return "Caminho nao encontrado!"

astar("Balsas", "Sao Luis", grafo, heuristica_manhattan)